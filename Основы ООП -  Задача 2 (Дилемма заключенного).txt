ФИТ НГУ, курс ООП, осенний семестр 2022
Задача 2a. Дилемма заключённого
История изменений
Общие сведения
Требуется реализовать консольное приложение, позволяющее симулировать повторяющуюся “Дилемму заключённого” (детали в Википедии: http://en.wikipedia.org/wiki/Prisoner's_dilemma) для троих заключённых.

Оригинальная задача в курсе SICP: https://github.com/yangchenyun/learning-sicp/blob/master/practices/assignments/06.prisoner-s-dilemma/ps4prs.pdf 


Устройство игры
1. Программа позволяет “соревноваться”  трём “заключённым” (далее - стратегиям). которые пытаются максимизировать набранные очки.
Выигрывает стратегия, по результатам игры (некоторого фиксированного количества ходов) набравшая наибольшее количество очков.

2. Игра протекает следующим образом: пошагово, в течение некоторого количества шагов, симулятор выясняет выбор каждой стратегии:
 сотрудничать (C) или предать (D). После этого, симулятор сообщает каждой стратегии выбор её оппонентов и вычисляет очки
 за текущий раунд. Очки вычисляются по матрице игры (пример матрицы в приложении).

3. Стратегии делают свой выбор основываясь на накопленном опыте: истории ходов оппонентов и собственной.
 Алгоритмы стратегий могут быть самыми различными, начиная от тривиальных “всегда сотрудничать” или
 “выдавать случайный результат”. Изначально, история ходов каждой стратегии пуста.

4. Симуляция может проходить в трёх режимах:
   1. Соревнование с детализацией. На каждом шаге программа ожидает нажатия клавиши от пользователя,
   после которого делает один шаг. Подробное состояние симуляции выводится после каждого шага
   (выбор каждой стратегии, очки за текущий ход, очки за текущую игру).
Игра прерывается по команде quit.
   2. Соревнование без детализации. Программа вычисляет заданное количество ходов и выводит результат.
   3. Турнир. Программа перебирает все возможные тройки (без повторений, т.е. s1,s2,s3 и s3,s2,s1 - одна и та же тройка)
   указанных стратегий и по общему результату выявляет победителя по сумме баллов за все игры.
    Результаты каждого соревнования и итоговый протокол выводятся на экран

Технические детали
      1. На старте программе подаются следующие аргументы командной строки:
      1. Три (или более - для турнирного режима) имени соревнующихся стратегий.
      2. Название режима --mode=[detailed|fast|tournament] (опциональный, по умолчанию - detailed для трех стратегий, tournament для >3 стратегий)
      3. Число шагов симуляции --steps=<n> (опциональный)
      4. Директория с конфигурационными файлами стратегий --configs=<dirname> (опциональный)
      5. Файл с матрицей игры --matrix=<filename>(опциональный)

         2. Технически, каждая стратегия представляется в виде класса. У стратегий выделяется общий абстрактный интерфейс.
         Нетривиальные стратегии хранят свои параметры в собственном конфигурационном файле произвольного формата.

         3. При сдаче необходимо продемонстрировать 3-5 тривиальных и 3-5 нетривиальных стратегии, включая “метастратегии” -
         использующие несколько других стратегий для принятия решения. Сложность/интересность стратегий не ограничивается.

         4. Для конструирования классов-стратегий следует использовать шаблон проектирования “Фабрика объектов”.

         5. Матрица игры описывает количество очков, получаемых стратегиями за каждый ход. Матрицу по умолчанию можно
         вшить в код программы. Пример правильной матрицы для игры с тремя заключёнными содержится в приложении.
         Формат файла с матрицей произволен.

         6. При реализации программы подразумевается максимальное использование STL.
          Для работы с файлами необходимо использовать файловые потоки, переключенные в режим сообщения об
          ошибках исключениями (см. метод std::ios::exceptions)

         7. Бизнес-логика симулятора должна быть покрыта модульными тестами.

         8. При сдаче, преподаватель может потребовать интегрировать в симулятор студента стратегии другого
          учащегося и устроить турнир.

         9. Поощряется реализация возможности динамической загрузки стратегий из динамических библиотек.

         10. Базовая функциональность игры должна быть покрыта модульными тестами


Приложение. Матрица игры
з1 з2 з3     з1 з2 з3
 С  С  С  =>  7  7  7  //заключённые 1, 2 и 3 получают по 7 очков
 C  C  D  =>  3  3  9
 C  D  C  =>  3  9  3
 D  C  C  =>  9  3  3
 C  D  D  =>  0  5  5
 D  C  D  =>  5  0  5
 D  D  C  =>  5  5  0
 D  D  D  =>  1  1  1